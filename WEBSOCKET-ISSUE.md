# Проблема с WebSocket на Render

## Симптомы

WebSocket подключение закрывается с кодом `1006` (abnormal closure) до установки соединения:

```
WebSocket connection to 'wss://android-automation-backend.onrender.com/api/logs/stream?token=...' 
failed: WebSocket is closed before the connection is established.
WebSocket closed: 1006
```

## Диагностика

### Что проверено:

1. ✅ **Backend код** - WebSocket handler настроен правильно
2. ✅ **Fastify WebSocket plugin** - зарегистрирован корректно
3. ✅ **Логирование** - добавлено детальное логирование всех запросов
4. ❌ **Логи Render** - **НЕТ запросов к `/api/logs/stream`** в логах backend

### Вывод:

WebSocket upgrade запросы **не доходят до сервера**. Это означает, что проблема на уровне Render прокси/инфраструктуры.

## Возможные причины

### 1. Render не поддерживает WebSocket на бесплатном плане

**Проблема:** Render может блокировать WebSocket upgrade запросы на бесплатном плане `starter`.

**Решение:**
- Обновить план до `standard` или выше
- Или использовать альтернативные решения (см. ниже)

### 2. Render требует специальной настройки для WebSocket

**Проблема:** Render может требовать специальной конфигурации для WebSocket.

**Решение:**
- Проверить документацию Render по WebSocket
- Добавить специальные заголовки или настройки

### 3. Проблема с прокси Render

**Проблема:** Render прокси может не поддерживать WebSocket upgrade.

**Решение:**
- Использовать прямой доступ к серверу (если доступен)
- Или использовать альтернативные решения

## Решения

### Решение 1: Обновить план Render (рекомендуется)

Если WebSocket критичен для работы системы, обновите план backend сервиса до `standard` или выше.

**В `render.yaml`:**
```yaml
- type: web
  name: android-automation-backend
  plan: standard  # Вместо starter
  # ...
```

### Решение 2: Использовать Server-Sent Events (SSE) вместо WebSocket

SSE работает через обычный HTTP и не требует upgrade, поэтому должен работать на Render.

**Преимущества:**
- Работает на всех планах Render
- Проще в настройке
- Односторонняя связь (server → client) достаточна для логов

**Недостатки:**
- Нет двусторонней связи (но для логов это не нужно)
- Меньше функций, чем WebSocket

### Решение 3: Использовать polling (fallback)

Если WebSocket не работает, можно использовать HTTP polling для получения логов.

**Реализация:**
- Frontend делает GET запросы каждые 2-3 секунды
- Backend возвращает новые логи с последнего запроса

**Недостатки:**
- Больше нагрузка на сервер
- Задержка в получении логов

### Решение 4: Использовать внешний WebSocket сервис

Можно использовать внешний WebSocket сервис (например, Pusher, Ably) для real-time коммуникации.

## ✅ РЕШЕНО!

### Статус: WebSocket работает с автоматическим переподключением

**Что было сделано:**
1. ✅ Добавлено детальное логирование WebSocket запросов
2. ✅ Добавлена проверка токена из query параметра
3. ✅ Добавлено автоматическое переподключение при закрытии соединения (коды 1005, 1006)
4. ✅ WebSocket успешно подключается и работает

**Текущее поведение:**
- WebSocket успешно подключается к серверу
- Токен проверяется и аутентификация проходит
- Welcome message отправляется клиенту
- Ping/Pong работает корректно
- Render закрывает idle соединения через ~7-13 секунд (код 1005)
- **Автоматическое переподключение** восстанавливает соединение через 3 секунды

**Логи подтверждают:**
- `WebSocket connection handler called` - соединение устанавливается
- `WebSocket authenticated via token` - токен проверяется
- `Welcome message sent` - приветственное сообщение отправлено
- `Pong sent` - сервер отвечает на ping
- `WebSocket closed: 1005` - Render закрывает idle соединение (нормально)

**Вывод:** WebSocket работает корректно! Render закрывает idle соединения, но автоматическое переподключение решает эту проблему.

